E:- 
1- for variable := start,end [,increment] stmt end for;


case Tag.FOR:{
	Stmt st;
	match(Tag.FOR);
	Token t=look;
	match(Tag.ID);
	Id i=top.get(t);
	if(i==null){error(t.massage())+" Undeclared"}
	match(':');
	match('=');
	match(Tag.NUM);
	match(',');
	match(Tag.NUM);
	if(look.tag==','){
	match(Tag.NUM);
	}
	st=stmt();
	match(Tag.end);
	match(';');
	return new For(st,i);
}

2- typedef union { body } ID; //I don't understand it

3- PRINT(argument);

case Tag.PRINT:{
	Stmt st=null;
	match(tag.PRINT);
	match('(');
	do{
	Token t=look;
	match(Tag.ID);
	Id i=top.get(t);
	if(i==null){error(t.massage())+" Undeclared"}
	st=new Print(id);
	}while(Tag.ID);

	match(')');
	match(';');
	return st;
}

4- [public|private|protected][static]{final|const} <type> id=expr;

void types(){
	Expr ex;
	if(look.tag==Tag.STATIC)
		match(Tag.STATIC);

	if(look.tag==Tag.FINAL)
	match(Tag.FINAL);
	else
	match(Tag.CONST);
	token t0=look;
	match(Tag.BASIC);
	Id i=top.get(t0);
	Token t=look;
	match(Tag.ID);
	top.put(t,i);
	match('=');
	ex=expr();
	match(';');

	return new Public(i,ex);
}

case Tag.PUBLIC:{
	match(Tag.PUBLIC);
	types();

	return null
}

case Tag.PRIVATE:{
	match(Tag.PRIVATE);
	types();

	return null
}

case Tag.PROTECTED:{
	match(Tag.PROTECTED);
	types();

	return null
}

5- id IS id

case Tag.ID:{
	Token t=look;
	match(Tag.ID);
	Id i=top.get(t);
	if(i==null){error(t.massage())+" Undeclared"}
	match(tag.IS);
	Token t1=look;
	match(Tag.ID);
	Id i1=top.get(t);
	if(i1==null){error(t1.massage())+" Undeclared"}
	return new Id(i,i1);
}

flex


stmt:
	|FOR ID COLON EQU NUM COMA NUM stmt END SEMICOLON
	|FOR ID COLON EQU NUM COMA NUM COMA NUM stmt END SEMICOLON
	|PRINT LEFT_PARENTHESIS ID RIGHT_PARENTHESIS SEMICOLON
	|PUBLIC FINAL BASIC id EQU expr SEMICOLON
	|PUBLIC CONST BASIC id EQU expr SEMICOLON
	|PRIVATE FINAL BASIC id EQU expr SEMICOLON
	|PROTECTED FINAL BASIC id EQU expr SEMICOLON 
	|ID IS ID 